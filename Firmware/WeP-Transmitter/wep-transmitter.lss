
wep-transmitter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  0000048a  0000051e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000048a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  00800100  00800100  0000051e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000051e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000550  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000068  00000000  00000000  00000590  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000013a7  00000000  00000000  000005f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d9b  00000000  00000000  0000199f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000004fe  00000000  00000000  0000273a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000200  00000000  00000000  00002c38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000612  00000000  00000000  00002e38  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000780  00000000  00000000  0000344a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  00003bca  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
   c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  10:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  14:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  18:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  1c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  20:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  24:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  28:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  2c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  30:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  34:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  38:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  3c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  40:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  44:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  48:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  4c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  50:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  54:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  58:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  5c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  60:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  64:	0c 94 92 00 	jmp	0x124	; 0x124 <__vector_25>
  68:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  6c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  70:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  74:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  78:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  7c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  80:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  84:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  88:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  8c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  90:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  94:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  98:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  9c:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a0:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a4:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>
  a8:	0c 94 68 00 	jmp	0xd0	; 0xd0 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_clear_bss>:
  b8:	21 e0       	ldi	r18, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	01 c0       	rjmp	.+2      	; 0xc2 <.do_clear_bss_start>

000000c0 <.do_clear_bss_loop>:
  c0:	1d 92       	st	X+, r1

000000c2 <.do_clear_bss_start>:
  c2:	ac 30       	cpi	r26, 0x0C	; 12
  c4:	b2 07       	cpc	r27, r18
  c6:	e1 f7       	brne	.-8      	; 0xc0 <.do_clear_bss_loop>
  c8:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <main>
  cc:	0c 94 43 02 	jmp	0x486	; 0x486 <_exit>

000000d0 <__bad_interrupt>:
  d0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d4 <init_serial>:
volatile uint8_t data[10];
volatile uint8_t dataidx = 0;
volatile uint8_t data_good = 0;

void init_serial() {
	DDRD |= (1 << PIND3);
  d4:	53 9a       	sbi	0x0a, 3	; 10
	DDRD &= ~(1 << PIND2);
  d6:	52 98       	cbi	0x0a, 2	; 10

 UCSR1A = 0;   
  d8:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7f80c8>
	UCSR1B |= (1 << TXEN1) | (1 << RXEN1) | (1 << RXCIE1);   // Turn on the transmission and reception circuitry
  dc:	e9 ec       	ldi	r30, 0xC9	; 201
  de:	f0 e0       	ldi	r31, 0x00	; 0
  e0:	80 81       	ld	r24, Z
  e2:	88 69       	ori	r24, 0x98	; 152
  e4:	80 83       	st	Z, r24
    UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);
  e6:	86 e0       	ldi	r24, 0x06	; 6
  e8:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7f80ca>
    UBRR1H = 0;
  ec:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7f80cd>
    UBRR1L = 25;
  f0:	89 e1       	ldi	r24, 0x19	; 25
  f2:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7f80cc>
  f6:	08 95       	ret

000000f8 <serial_putc>:
}

void serial_putc(char c) {
	while ((UCSR1A & (1<<UDRE1))==0);
  f8:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7f80c8>
  fc:	95 ff       	sbrs	r25, 5
  fe:	fc cf       	rjmp	.-8      	; 0xf8 <serial_putc>
	UDR1 = c;
 100:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7f80ce>
 104:	08 95       	ret

00000106 <serial_send>:
}

void serial_send(char* send) {
    while (*send) {
 106:	fc 01       	movw	r30, r24
 108:	20 81       	ld	r18, Z
 10a:	22 23       	and	r18, r18
 10c:	51 f0       	breq	.+20     	; 0x122 <serial_send+0x1c>
 10e:	31 96       	adiw	r30, 0x01	; 1
    UBRR1H = 0;
    UBRR1L = 25;
}

void serial_putc(char c) {
	while ((UCSR1A & (1<<UDRE1))==0);
 110:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7f80c8>
 114:	95 ff       	sbrs	r25, 5
 116:	fc cf       	rjmp	.-8      	; 0x110 <serial_send+0xa>
	UDR1 = c;
 118:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7f80ce>
}

void serial_send(char* send) {
    while (*send) {
 11c:	21 91       	ld	r18, Z+
 11e:	21 11       	cpse	r18, r1
 120:	f7 cf       	rjmp	.-18     	; 0x110 <serial_send+0xa>
 122:	08 95       	ret

00000124 <__vector_25>:
        serial_putc(*send++);
    }
}

ISR(USART1_RX_vect)
{
 124:	1f 92       	push	r1
 126:	0f 92       	push	r0
 128:	0f b6       	in	r0, 0x3f	; 63
 12a:	0f 92       	push	r0
 12c:	11 24       	eor	r1, r1
 12e:	8f 93       	push	r24
 130:	ef 93       	push	r30
 132:	ff 93       	push	r31

        char c = UDR1;
 134:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7f80ce>
        if(c != '\r') {
 138:	8d 30       	cpi	r24, 0x0D	; 13
 13a:	b9 f0       	breq	.+46     	; 0x16a <__vector_25+0x46>
            data[dataidx] = c;
 13c:	e0 91 01 01 	lds	r30, 0x0101	; 0x800101 <dataidx>
 140:	f0 e0       	ldi	r31, 0x00	; 0
 142:	ee 5f       	subi	r30, 0xFE	; 254
 144:	fe 4f       	sbci	r31, 0xFE	; 254
 146:	80 83       	st	Z, r24
            dataidx++;
 148:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <dataidx>
 14c:	8f 5f       	subi	r24, 0xFF	; 255
 14e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <dataidx>
            if(dataidx == 10) {
 152:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <dataidx>
 156:	8a 30       	cpi	r24, 0x0A	; 10
 158:	a1 f0       	breq	.+40     	; 0x182 <__vector_25+0x5e>
                	PORTF |= (1 << PORTF0);

            data_good = 1;
        }
    
}
 15a:	ff 91       	pop	r31
 15c:	ef 91       	pop	r30
 15e:	8f 91       	pop	r24
 160:	0f 90       	pop	r0
 162:	0f be       	out	0x3f, r0	; 63
 164:	0f 90       	pop	r0
 166:	1f 90       	pop	r1
 168:	18 95       	reti
            dataidx++;
            if(dataidx == 10) {
                dataidx = 0;
            }
        } else {
                	PORTF |= (1 << PORTF0);
 16a:	88 9a       	sbi	0x11, 0	; 17

            data_good = 1;
 16c:	81 e0       	ldi	r24, 0x01	; 1
 16e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
        }
    
}
 172:	ff 91       	pop	r31
 174:	ef 91       	pop	r30
 176:	8f 91       	pop	r24
 178:	0f 90       	pop	r0
 17a:	0f be       	out	0x3f, r0	; 63
 17c:	0f 90       	pop	r0
 17e:	1f 90       	pop	r1
 180:	18 95       	reti
        char c = UDR1;
        if(c != '\r') {
            data[dataidx] = c;
            dataidx++;
            if(dataidx == 10) {
                dataidx = 0;
 182:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <dataidx>
                	PORTF |= (1 << PORTF0);

            data_good = 1;
        }
    
}
 186:	ff 91       	pop	r31
 188:	ef 91       	pop	r30
 18a:	8f 91       	pop	r24
 18c:	0f 90       	pop	r0
 18e:	0f be       	out	0x3f, r0	; 63
 190:	0f 90       	pop	r0
 192:	1f 90       	pop	r1
 194:	18 95       	reti

00000196 <nrf24l01_write_register>:
#include <include/nrf24l01.h>
#include <include/spi.h>
#define F_CPU 16000000UL
#include <util/delay.h>

void nrf24l01_write_register(uint8_t reg, uint8_t* data, uint8_t bytecount) {
 196:	ff 92       	push	r15
 198:	0f 93       	push	r16
 19a:	1f 93       	push	r17
 19c:	cf 93       	push	r28
 19e:	df 93       	push	r29
 1a0:	c8 2f       	mov	r28, r24
 1a2:	f6 2e       	mov	r15, r22
 1a4:	07 2f       	mov	r16, r23
 1a6:	14 2f       	mov	r17, r20
	reg =  NRF_WRITE + reg;
	SPI_unset_cs();
 1a8:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <SPI_unset_cs>
	SPI_send(reg);
 1ac:	80 e2       	ldi	r24, 0x20	; 32
 1ae:	8c 0f       	add	r24, r28
 1b0:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>
	for(int i = 0; i < bytecount; i++) {
 1b4:	11 23       	and	r17, r17
 1b6:	61 f0       	breq	.+24     	; 0x1d0 <nrf24l01_write_register+0x3a>
 1b8:	cf 2d       	mov	r28, r15
 1ba:	d0 2f       	mov	r29, r16
 1bc:	ce 01       	movw	r24, r28
 1be:	81 0f       	add	r24, r17
 1c0:	91 1d       	adc	r25, r1
 1c2:	8c 01       	movw	r16, r24
		SPI_send(data[i]);
 1c4:	89 91       	ld	r24, Y+
 1c6:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>

void nrf24l01_write_register(uint8_t reg, uint8_t* data, uint8_t bytecount) {
	reg =  NRF_WRITE + reg;
	SPI_unset_cs();
	SPI_send(reg);
	for(int i = 0; i < bytecount; i++) {
 1ca:	c0 17       	cp	r28, r16
 1cc:	d1 07       	cpc	r29, r17
 1ce:	d1 f7       	brne	.-12     	; 0x1c4 <nrf24l01_write_register+0x2e>
		SPI_send(data[i]);
	}
	SPI_set_cs();
}
 1d0:	df 91       	pop	r29
 1d2:	cf 91       	pop	r28
 1d4:	1f 91       	pop	r17
 1d6:	0f 91       	pop	r16
 1d8:	ff 90       	pop	r15
	SPI_unset_cs();
	SPI_send(reg);
	for(int i = 0; i < bytecount; i++) {
		SPI_send(data[i]);
	}
	SPI_set_cs();
 1da:	0c 94 e3 01 	jmp	0x3c6	; 0x3c6 <SPI_set_cs>

000001de <nrf24l01_init>:
}

void nrf24l01_init(uint8_t address_width, uint8_t* address, uint8_t channel, uint8_t payload_width, uint8_t mode) {
 1de:	bf 92       	push	r11
 1e0:	cf 92       	push	r12
 1e2:	df 92       	push	r13
 1e4:	ef 92       	push	r14
 1e6:	ff 92       	push	r15
 1e8:	0f 93       	push	r16
 1ea:	1f 93       	push	r17
 1ec:	cf 93       	push	r28
 1ee:	df 93       	push	r29
 1f0:	1f 92       	push	r1
 1f2:	cd b7       	in	r28, 0x3d	; 61
 1f4:	de b7       	in	r29, 0x3e	; 62
 1f6:	18 2f       	mov	r17, r24
 1f8:	7b 01       	movw	r14, r22
 1fa:	b4 2e       	mov	r11, r20
 1fc:	c2 2e       	mov	r12, r18
	
	// Setup CE pin that enables RF activity (not to be confused with the CSN pin, which is for the SPI)
	DDRB |= (1 << DDB7);
 1fe:	27 9a       	sbi	0x04, 7	; 4
	PORTB &= ~(1 << PORTB7);
 200:	2f 98       	cbi	0x05, 7	; 5

	uint8_t config_values[1];
	
	//Enable Auto-ACK
	config_values[0] = 0x01;
 202:	dd 24       	eor	r13, r13
 204:	d3 94       	inc	r13
 206:	d9 82       	std	Y+1, r13	; 0x01
	nrf24l01_write_register(EN_AA, config_values, 1);
 208:	41 e0       	ldi	r20, 0x01	; 1
 20a:	be 01       	movw	r22, r28
 20c:	6f 5f       	subi	r22, 0xFF	; 255
 20e:	7f 4f       	sbci	r23, 0xFF	; 255
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Setup automatic retries 750uS delay, up to 15 times
	config_values[0] = 0x2F;
 216:	8f e2       	ldi	r24, 0x2F	; 47
 218:	89 83       	std	Y+1, r24	; 0x01
	nrf24l01_write_register(SETUP_RETR, config_values, 1);
 21a:	41 e0       	ldi	r20, 0x01	; 1
 21c:	be 01       	movw	r22, r28
 21e:	6f 5f       	subi	r22, 0xFF	; 255
 220:	7f 4f       	sbci	r23, 0xFF	; 255
 222:	84 e0       	ldi	r24, 0x04	; 4
 224:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Enable data pipe 0 for recieve communications
	config_values[0] = 0x01;
 228:	d9 82       	std	Y+1, r13	; 0x01
	nrf24l01_write_register(EN_RXADDR, config_values, 1);
 22a:	41 e0       	ldi	r20, 0x01	; 1
 22c:	be 01       	movw	r22, r28
 22e:	6f 5f       	subi	r22, 0xFF	; 255
 230:	7f 4f       	sbci	r23, 0xFF	; 255
 232:	82 e0       	ldi	r24, 0x02	; 2
 234:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Set address length as 5 bytes
	config_values[0] = address_width;
 238:	19 83       	std	Y+1, r17	; 0x01
	nrf24l01_write_register(SETUP_AW, config_values,1);
 23a:	41 e0       	ldi	r20, 0x01	; 1
 23c:	be 01       	movw	r22, r28
 23e:	6f 5f       	subi	r22, 0xFF	; 255
 240:	7f 4f       	sbci	r23, 0xFF	; 255
 242:	83 e0       	ldi	r24, 0x03	; 3
 244:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Setup a radio channel
	config_values[0] = channel;
 248:	b9 82       	std	Y+1, r11	; 0x01
	nrf24l01_write_register(RF_CH, config_values,1);
 24a:	41 e0       	ldi	r20, 0x01	; 1
 24c:	be 01       	movw	r22, r28
 24e:	6f 5f       	subi	r22, 0xFF	; 255
 250:	7f 4f       	sbci	r23, 0xFF	; 255
 252:	85 e0       	ldi	r24, 0x05	; 5
 254:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>

	//Setup in -0dB long range mode
	config_values[0] = 0x07;
 258:	87 e0       	ldi	r24, 0x07	; 7
 25a:	89 83       	std	Y+1, r24	; 0x01
	nrf24l01_write_register(RF_SETUP, config_values,1);
 25c:	41 e0       	ldi	r20, 0x01	; 1
 25e:	be 01       	movw	r22, r28
 260:	6f 5f       	subi	r22, 0xFF	; 255
 262:	7f 4f       	sbci	r23, 0xFF	; 255
 264:	86 e0       	ldi	r24, 0x06	; 6
 266:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Setup addresses for recieve pipe 0 and tx
	nrf24l01_write_register(RX_ADDR_P0,address,address_width);
 26a:	41 2f       	mov	r20, r17
 26c:	b7 01       	movw	r22, r14
 26e:	8a e0       	ldi	r24, 0x0A	; 10
 270:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	nrf24l01_write_register(TX_ADDR,address,address_width);
 274:	41 2f       	mov	r20, r17
 276:	b7 01       	movw	r22, r14
 278:	80 e1       	ldi	r24, 0x10	; 16
 27a:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Setup payload width (bytes/package)
	config_values[0] = payload_width;
 27e:	c9 82       	std	Y+1, r12	; 0x01
	nrf24l01_write_register(RX_PW_P0,config_values,1);
 280:	41 e0       	ldi	r20, 0x01	; 1
 282:	be 01       	movw	r22, r28
 284:	6f 5f       	subi	r22, 0xFF	; 255
 286:	7f 4f       	sbci	r23, 0xFF	; 255
 288:	81 e1       	ldi	r24, 0x11	; 17
 28a:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
	
	//Bootup and config
	config_values[0] = (1 << PWR_UP) | (1 << CRCO) | (1 << EN_CRC) | (1 << MASK_MAX_RT);
	
	if(mode == 0) {
 28e:	00 23       	and	r16, r16
 290:	a1 f0       	breq	.+40     	; 0x2ba <nrf24l01_init+0xdc>
		config_values[0] = 0x1E;
		//config_values[0] |=  (1 << MASK_TX_DS) | (1 << MASK_RX_DR);
	} else {
		config_values[0] |= (1 << PRIM_RX) | (1 << MASK_TX_DS);
 292:	8f e3       	ldi	r24, 0x3F	; 63
 294:	89 83       	std	Y+1, r24	; 0x01
	}
	nrf24l01_write_register(CONFIG, config_values, 1);
 296:	41 e0       	ldi	r20, 0x01	; 1
 298:	be 01       	movw	r22, r28
 29a:	6f 5f       	subi	r22, 0xFF	; 255
 29c:	7f 4f       	sbci	r23, 0xFF	; 255
 29e:	80 e0       	ldi	r24, 0x00	; 0
 2a0:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
} 
 2a4:	0f 90       	pop	r0
 2a6:	df 91       	pop	r29
 2a8:	cf 91       	pop	r28
 2aa:	1f 91       	pop	r17
 2ac:	0f 91       	pop	r16
 2ae:	ff 90       	pop	r15
 2b0:	ef 90       	pop	r14
 2b2:	df 90       	pop	r13
 2b4:	cf 90       	pop	r12
 2b6:	bf 90       	pop	r11
 2b8:	08 95       	ret
	//Setup payload width (bytes/package)
	config_values[0] = payload_width;
	nrf24l01_write_register(RX_PW_P0,config_values,1);
	
	//Bootup and config
	config_values[0] = (1 << PWR_UP) | (1 << CRCO) | (1 << EN_CRC) | (1 << MASK_MAX_RT);
 2ba:	8e e1       	ldi	r24, 0x1E	; 30
 2bc:	89 83       	std	Y+1, r24	; 0x01
 2be:	eb cf       	rjmp	.-42     	; 0x296 <nrf24l01_init+0xb8>

000002c0 <nrf24l01_transmit>:
		config_values[0] |= (1 << PRIM_RX) | (1 << MASK_TX_DS);
	}
	nrf24l01_write_register(CONFIG, config_values, 1);
} 

void nrf24l01_transmit(uint8_t* payload, uint8_t payload_size) {
 2c0:	ff 92       	push	r15
 2c2:	0f 93       	push	r16
 2c4:	1f 93       	push	r17
 2c6:	cf 93       	push	r28
 2c8:	df 93       	push	r29
 2ca:	f8 2e       	mov	r15, r24
 2cc:	09 2f       	mov	r16, r25
 2ce:	16 2f       	mov	r17, r22
	SPI_unset_cs();
 2d0:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <SPI_unset_cs>
	SPI_send(FLUSH_TX);
 2d4:	81 ee       	ldi	r24, 0xE1	; 225
 2d6:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>
	SPI_set_cs();
 2da:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <SPI_set_cs>
	
	SPI_unset_cs();
 2de:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <SPI_unset_cs>
	SPI_send(W_TX_PAYLOAD);
 2e2:	80 ea       	ldi	r24, 0xA0	; 160
 2e4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>
	for(int i = 0; i < payload_size; i++) {
 2e8:	11 23       	and	r17, r17
 2ea:	61 f0       	breq	.+24     	; 0x304 <nrf24l01_transmit+0x44>
 2ec:	cf 2d       	mov	r28, r15
 2ee:	d0 2f       	mov	r29, r16
 2f0:	ce 01       	movw	r24, r28
 2f2:	81 0f       	add	r24, r17
 2f4:	91 1d       	adc	r25, r1
 2f6:	8c 01       	movw	r16, r24
		SPI_send(payload[i]);
 2f8:	89 91       	ld	r24, Y+
 2fa:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>
	SPI_send(FLUSH_TX);
	SPI_set_cs();
	
	SPI_unset_cs();
	SPI_send(W_TX_PAYLOAD);
	for(int i = 0; i < payload_size; i++) {
 2fe:	c0 17       	cp	r28, r16
 300:	d1 07       	cpc	r29, r17
 302:	d1 f7       	brne	.-12     	; 0x2f8 <nrf24l01_transmit+0x38>
		SPI_send(payload[i]);
	}
	SPI_set_cs();
 304:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <SPI_set_cs>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 308:	8f e3       	ldi	r24, 0x3F	; 63
 30a:	9c e9       	ldi	r25, 0x9C	; 156
 30c:	01 97       	sbiw	r24, 0x01	; 1
 30e:	f1 f7       	brne	.-4      	; 0x30c <nrf24l01_transmit+0x4c>
 310:	00 c0       	rjmp	.+0      	; 0x312 <nrf24l01_transmit+0x52>
 312:	00 00       	nop
	_delay_ms(10);
	PORTB |= (1 << PORTB7);
 314:	2f 9a       	sbi	0x05, 7	; 5
 316:	9f ef       	ldi	r25, 0xFF	; 255
 318:	29 ef       	ldi	r18, 0xF9	; 249
 31a:	80 e0       	ldi	r24, 0x00	; 0
 31c:	91 50       	subi	r25, 0x01	; 1
 31e:	20 40       	sbci	r18, 0x00	; 0
 320:	80 40       	sbci	r24, 0x00	; 0
 322:	e1 f7       	brne	.-8      	; 0x31c <nrf24l01_transmit+0x5c>
 324:	00 c0       	rjmp	.+0      	; 0x326 <nrf24l01_transmit+0x66>
 326:	00 00       	nop
	_delay_ms(20);
	PORTB &= ~(1 << PORTB7);
 328:	2f 98       	cbi	0x05, 7	; 5
 32a:	8f e3       	ldi	r24, 0x3F	; 63
 32c:	9c e9       	ldi	r25, 0x9C	; 156
 32e:	01 97       	sbiw	r24, 0x01	; 1
 330:	f1 f7       	brne	.-4      	; 0x32e <nrf24l01_transmit+0x6e>
 332:	00 c0       	rjmp	.+0      	; 0x334 <nrf24l01_transmit+0x74>
 334:	00 00       	nop
	_delay_ms(10);
}
 336:	df 91       	pop	r29
 338:	cf 91       	pop	r28
 33a:	1f 91       	pop	r17
 33c:	0f 91       	pop	r16
 33e:	ff 90       	pop	r15
 340:	08 95       	ret

00000342 <nrf24l01_read_register>:

void nrf24l01_read_register(uint8_t reg, uint8_t* data, uint8_t bytecount) {
 342:	ff 92       	push	r15
 344:	0f 93       	push	r16
 346:	1f 93       	push	r17
 348:	cf 93       	push	r28
 34a:	df 93       	push	r29
 34c:	c8 2f       	mov	r28, r24
 34e:	f6 2e       	mov	r15, r22
 350:	07 2f       	mov	r16, r23
 352:	14 2f       	mov	r17, r20
	SPI_unset_cs();
 354:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <SPI_unset_cs>
	SPI_send(reg);
 358:	8c 2f       	mov	r24, r28
 35a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>
	for(int i = 0; i < bytecount; i++) {
 35e:	11 23       	and	r17, r17
 360:	71 f0       	breq	.+28     	; 0x37e <nrf24l01_read_register+0x3c>
 362:	cf 2d       	mov	r28, r15
 364:	d0 2f       	mov	r29, r16
 366:	ce 01       	movw	r24, r28
 368:	81 0f       	add	r24, r17
 36a:	91 1d       	adc	r25, r1
 36c:	8c 01       	movw	r16, r24
		SPI_send(NOP);
 36e:	8f ef       	ldi	r24, 0xFF	; 255
 370:	0e 94 e5 01 	call	0x3ca	; 0x3ca <SPI_send>
		data[i] = SPDR;
 374:	8e b5       	in	r24, 0x2e	; 46
 376:	89 93       	st	Y+, r24
}

void nrf24l01_read_register(uint8_t reg, uint8_t* data, uint8_t bytecount) {
	SPI_unset_cs();
	SPI_send(reg);
	for(int i = 0; i < bytecount; i++) {
 378:	c0 17       	cp	r28, r16
 37a:	d1 07       	cpc	r29, r17
 37c:	c1 f7       	brne	.-16     	; 0x36e <nrf24l01_read_register+0x2c>
		SPI_send(NOP);
		data[i] = SPDR;
	}
	SPI_set_cs();
}
 37e:	df 91       	pop	r29
 380:	cf 91       	pop	r28
 382:	1f 91       	pop	r17
 384:	0f 91       	pop	r16
 386:	ff 90       	pop	r15
	SPI_send(reg);
	for(int i = 0; i < bytecount; i++) {
		SPI_send(NOP);
		data[i] = SPDR;
	}
	SPI_set_cs();
 388:	0c 94 e3 01 	jmp	0x3c6	; 0x3c6 <SPI_set_cs>

0000038c <nrf24l01_reset_interrupts>:
}

void nrf24l01_reset_interrupts() {
 38c:	cf 93       	push	r28
 38e:	df 93       	push	r29
 390:	1f 92       	push	r1
 392:	cd b7       	in	r28, 0x3d	; 61
 394:	de b7       	in	r29, 0x3e	; 62
	uint8_t val[1];
	val[0] = (1 << MAX_RT) | (1 << TX_DS) | (1 << RX_DR);
 396:	80 e7       	ldi	r24, 0x70	; 112
 398:	89 83       	std	Y+1, r24	; 0x01
	nrf24l01_write_register(STATUS,val,1);
 39a:	41 e0       	ldi	r20, 0x01	; 1
 39c:	be 01       	movw	r22, r28
 39e:	6f 5f       	subi	r22, 0xFF	; 255
 3a0:	7f 4f       	sbci	r23, 0xFF	; 255
 3a2:	87 e0       	ldi	r24, 0x07	; 7
 3a4:	0e 94 cb 00 	call	0x196	; 0x196 <nrf24l01_write_register>
}
 3a8:	0f 90       	pop	r0
 3aa:	df 91       	pop	r29
 3ac:	cf 91       	pop	r28
 3ae:	08 95       	ret

000003b0 <SPI_init>:
#include <avr/io.h>
#include <include/spi.h>

void SPI_init() {
	DDRB |= (1 << DDB0) | (1 << DDB1) | (1 << DDB2);
 3b0:	84 b1       	in	r24, 0x04	; 4
 3b2:	87 60       	ori	r24, 0x07	; 7
 3b4:	84 b9       	out	0x04, r24	; 4
	DDRB &= ~(1 << DDB3);
 3b6:	23 98       	cbi	0x04, 3	; 4
	SPCR|=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
 3b8:	8c b5       	in	r24, 0x2c	; 44
 3ba:	81 65       	ori	r24, 0x51	; 81
 3bc:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1 << PINB0);
 3be:	28 9a       	sbi	0x05, 0	; 5
 3c0:	08 95       	ret

000003c2 <SPI_unset_cs>:
}

void SPI_unset_cs() {
    PORTB &= ~(1 << PINB0);
 3c2:	28 98       	cbi	0x05, 0	; 5
 3c4:	08 95       	ret

000003c6 <SPI_set_cs>:
}

void SPI_set_cs(){
    PORTB |= (1 << PINB0);
 3c6:	28 9a       	sbi	0x05, 0	; 5
 3c8:	08 95       	ret

000003ca <SPI_send>:
}

void SPI_send(uint8_t data) {
	SPDR = data;
 3ca:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF) ));
 3cc:	0d b4       	in	r0, 0x2d	; 45
 3ce:	07 fe       	sbrs	r0, 7
 3d0:	fd cf       	rjmp	.-6      	; 0x3cc <SPI_send+0x2>
 3d2:	08 95       	ret

000003d4 <main>:


int main() {
 3d4:	cf 93       	push	r28
 3d6:	df 93       	push	r29
 3d8:	00 d0       	rcall	.+0      	; 0x3da <main+0x6>
 3da:	00 d0       	rcall	.+0      	; 0x3dc <main+0x8>
 3dc:	1f 92       	push	r1
 3de:	cd b7       	in	r28, 0x3d	; 61
 3e0:	de b7       	in	r29, 0x3e	; 62
volatile uint8_t data[10];
volatile uint8_t dataidx = 0;
volatile uint8_t data_good = 0;

void init_serial() {
	DDRD |= (1 << PIND3);
 3e2:	53 9a       	sbi	0x0a, 3	; 10
	DDRD &= ~(1 << PIND2);
 3e4:	52 98       	cbi	0x0a, 2	; 10

 UCSR1A = 0;   
 3e6:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7f80c8>
	UCSR1B |= (1 << TXEN1) | (1 << RXEN1) | (1 << RXCIE1);   // Turn on the transmission and reception circuitry
 3ea:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7f80c9>
 3ee:	88 69       	ori	r24, 0x98	; 152
 3f0:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7f80c9>
    UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);
 3f4:	86 e0       	ldi	r24, 0x06	; 6
 3f6:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7f80ca>
    UBRR1H = 0;
 3fa:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7f80cd>
    UBRR1L = 25;
 3fe:	89 e1       	ldi	r24, 0x19	; 25
 400:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7f80cc>


int main() {
	
	init_serial();
    sei();
 404:	78 94       	sei

	//DEBUG led
	DDRF = (1 << DDF0);
 406:	81 e0       	ldi	r24, 0x01	; 1
 408:	80 bb       	out	0x10, r24	; 16
	
	SPI_init();
 40a:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <SPI_init>
 40e:	2f ef       	ldi	r18, 0xFF	; 255
 410:	83 ed       	ldi	r24, 0xD3	; 211
 412:	90 e3       	ldi	r25, 0x30	; 48
 414:	21 50       	subi	r18, 0x01	; 1
 416:	80 40       	sbci	r24, 0x00	; 0
 418:	90 40       	sbci	r25, 0x00	; 0
 41a:	e1 f7       	brne	.-8      	; 0x414 <__EEPROM_REGION_LENGTH__+0x14>
 41c:	00 c0       	rjmp	.+0      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 41e:	00 00       	nop
	_delay_ms(1000);
	
	uint8_t address[5];
	for(int i = 0; i < 5; i++) {
		address[i] = 0x12+i;
 420:	82 e1       	ldi	r24, 0x12	; 18
 422:	89 83       	std	Y+1, r24	; 0x01
 424:	83 e1       	ldi	r24, 0x13	; 19
 426:	8a 83       	std	Y+2, r24	; 0x02
 428:	84 e1       	ldi	r24, 0x14	; 20
 42a:	8b 83       	std	Y+3, r24	; 0x03
 42c:	85 e1       	ldi	r24, 0x15	; 21
 42e:	8c 83       	std	Y+4, r24	; 0x04
 430:	86 e1       	ldi	r24, 0x16	; 22
 432:	8d 83       	std	Y+5, r24	; 0x05
    }
	
	nrf24l01_init(5, address, 110, 10 ,MODE_TRANSMIT);
 434:	00 e0       	ldi	r16, 0x00	; 0
 436:	2a e0       	ldi	r18, 0x0A	; 10
 438:	4e e6       	ldi	r20, 0x6E	; 110
 43a:	be 01       	movw	r22, r28
 43c:	6f 5f       	subi	r22, 0xFF	; 255
 43e:	7f 4f       	sbci	r23, 0xFF	; 255
 440:	85 e0       	ldi	r24, 0x05	; 5
 442:	0e 94 ef 00 	call	0x1de	; 0x1de <nrf24l01_init>
	
	nrf24l01_transmit(data,10);
 446:	6a e0       	ldi	r22, 0x0A	; 10
 448:	82 e0       	ldi	r24, 0x02	; 2
 44a:	91 e0       	ldi	r25, 0x01	; 1
 44c:	0e 94 60 01 	call	0x2c0	; 0x2c0 <nrf24l01_transmit>
	nrf24l01_reset_interrupts();
 450:	0e 94 c6 01 	call	0x38c	; 0x38c <nrf24l01_reset_interrupts>
    UBRR1L = 25;
}

void serial_putc(char c) {
	while ((UCSR1A & (1<<UDRE1))==0);
	UDR1 = c;
 454:	1b e4       	ldi	r17, 0x4B	; 75
	nrf24l01_transmit(data,10);
	nrf24l01_reset_interrupts();
		

    while(1) {
        if(data_good) {
 456:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 45a:	88 23       	and	r24, r24
 45c:	e1 f3       	breq	.-8      	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
        	PORTF |= (1 << PORTF0);
 45e:	88 9a       	sbi	0x11, 0	; 17
            nrf24l01_transmit(data,10);
 460:	6a e0       	ldi	r22, 0x0A	; 10
 462:	82 e0       	ldi	r24, 0x02	; 2
 464:	91 e0       	ldi	r25, 0x01	; 1
 466:	0e 94 60 01 	call	0x2c0	; 0x2c0 <nrf24l01_transmit>
            nrf24l01_reset_interrupts();
 46a:	0e 94 c6 01 	call	0x38c	; 0x38c <nrf24l01_reset_interrupts>
            PORTF &= ~(1 << PORTF0);
 46e:	88 98       	cbi	0x11, 0	; 17
            dataidx = 0;
 470:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <dataidx>
            data_good = 0;
 474:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
    UBRR1H = 0;
    UBRR1L = 25;
}

void serial_putc(char c) {
	while ((UCSR1A & (1<<UDRE1))==0);
 478:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7f80c8>
 47c:	85 ff       	sbrs	r24, 5
 47e:	fc cf       	rjmp	.-8      	; 0x478 <__EEPROM_REGION_LENGTH__+0x78>
	UDR1 = c;
 480:	10 93 ce 00 	sts	0x00CE, r17	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7f80ce>
 484:	e8 cf       	rjmp	.-48     	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>

00000486 <_exit>:
 486:	f8 94       	cli

00000488 <__stop_program>:
 488:	ff cf       	rjmp	.-2      	; 0x488 <__stop_program>
